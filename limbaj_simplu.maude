mod LIMBAJ-SIMPLU is
	including INT .
	including BOOL .
	sorts AExp BExp Command Pgm .
	sorts Id .
	sort Store .
	sort Cfg .
	sort Code .

	subsorts Id Int < AExp .
	subsorts Bool < BExp .
	op empty : -> Store [ctor] .
	op skip : -> Code [ctor] .

	op lookup : Store Id -> Int .
	op update : Store Id Int -> Store .
	
	--- It should have a gather (E e)
	op _~>_ : AExp Code -> Code [ctor] .
	op _~>_ : BExp Code -> Code	[ctor] .
	op _~>_ : Code Code -> Code [ctor] .

	op _plus_ : AExp AExp -> AExp [ctor prec 20] .
	op _times_ : AExp AExp -> AExp [ctor prec 10] .
	--- Works when returns an Int. 
	op inc_ : Id -> Int .
	op hole : -> AExp [ctor] .

	ops x y z : -> Id [ctor] .

	op <_,_> : Code Store -> Cfg [ctor] .
	op <_,_> : BExp Store -> Cfg [ctor] .

	--- Now begin the boolean expressions
	op _ge_ : AExp AExp -> BExp [prec 29 gather (E e)] .
	op _le_ : AExp AExp -> BExp [prec 29 gather (E e)] .
	op _eq_ : AExp AExp -> BExp [prec 29 gather (E e)] .


	--- Come up with better precedence values 
	op _&&_ : BExp BExp -> BExp [gather (E e)] .
	op _||_ : BExp BExp -> BExp [prec 31 gather (E e)] .
	op !_ : BExp -> BExp [prec 30] .

	--- Statement related operators

	op _<-_ : Id AExp -> Code .

	op {_} : Code -> Code [ctor] .
	op if_then_else_ : BExp Code Code -> Code .
	op while_do_od : BExp Code -> Code [ctor] .
	op halt_ :  AExp -> Code [ctor] .


	var STORE STORE1 STORE2 : Store .
	var I J : Int .
	var b1 b2 : Bool .
	var X : Id .  
	var C C1 C2 : Code .
	var E E1 E2 : AExp .
	var B1 B2 : BExp .

	--- Maybe switch from something else besides 0
	eq lookup(empty,X) = 0 .
	eq lookup(update(STORE, x, I), x) = I .
	eq lookup(update(STORE, x, I), y) = lookup(STORE,y) .
	eq lookup(update(STORE, x, I), z) = lookup(STORE,z) .  

	eq lookup(update(STORE, y, I), y) = I .
	eq lookup(update(STORE, y, I), x) = lookup(STORE,x) .
	eq lookup(update(STORE, y, I), z) = lookup(STORE,z) .

	eq lookup(update(STORE, z, I), z) = I .
	eq lookup(update(STORE, z, I), y) = lookup(STORE,y) .
	eq lookup(update(STORE, z, I), x) = lookup(STORE,x) .

---	eq !(true) = false .
----	eq !(false) = true .
	--- Do we really need to include this heating / cooling of the variable?
	rl [rule1] : < X plus E ~> C, STORE > => < X ~> hole plus E ~> C, STORE > .

	rl [rule2] : < (E1 plus E2) plus E ~> C, STORE > => < (E1 plus E2) ~> hole plus E ~> C, STORE > .
	rl [rule3] : < (E1 times E2) plus E ~> C, STORE > => < (E1 times E2) ~> hole plus E ~> C, STORE > .

	rl [rule4] : < I ~> hole plus E ~> C, STORE > => < I plus E ~> C, STORE > .
	rl [rule6] : < X ~> C, STORE > => < lookup(STORE, X) ~> C, STORE > .

	rl [rule7] : < J plus X ~> C, STORE > => < X ~> J plus hole ~> C, STORE > .
	rl [rule7] : < J plus (E1 plus E2) ~> C, STORE > => < (E1 plus E2) ~> J plus hole ~> C, STORE > .

	rl [rule8] : < J plus (E1 times E2) ~> C, STORE > => <(E1 times E2) ~> J plus hole ~> C, STORE > .

	rl [rule5] : < I ~> J plus hole ~> C, STORE > => < I + J ~> C, STORE > .
	rl [rule9] : < J plus I ~> C, STORE > => < J + I ~> C, STORE > .


	crl [increment] : < inc X ~> C, STORE > => < C , update(STORE, X, I) > if 
							< lookup(STORE, X) plus 1 ~> C, STORE > => < I ~> C, STORE > .

	crl [greaterThan] : < E1 ge E2 ~> C , STORE > => < I >= J ~> C , STORE2 > if
						< E1 ~> C , STORE > => < I ~> C, STORE1 > /\ 
						< E2 ~> C, STORE1 > => < J ~> C, STORE2 > .

	crl [lowerThan] : < E1 le E2 ~> C, STORE > => < I <= J ~> C, STORE2 > if
						< E1 ~> C, STORE > => < I ~> C, STORE1 > /\ 
						< E2 ~> C, STORE1 > => < J ~> C, STORE2 > .	

	crl [equals] : < E1 eq E2 ~> C , STORE > => < (I == J) ~> C , STORE2 > if
							< E1 ~> C, STORE > => < I ~> C , STORE1 > /\ 
							< E2 ~> C, STORE1 > => < J ~> C , STORE2 > .
	
	crl [logicalAnd] : < B1 && B2 ~> C, STORE > => < (b1 and b2) ~> C, STORE2 > if
							< B1 ~> C, STORE > => < b1 ~> C, STORE1 > /\
							< B2 ~> C, STORE1 > => < b2 ~> C, STORE2 > .


	crl [logicalOr] : < B1 || B2 ~> C, STORE > => < (b1 or b2) ~> C, STORE2 > if
							< B1 ~> C, STORE > => < b1 ~> C, STORE1 > /\
							< B2 ~> C, STORE1 > => < b2 ~> C, STORE2 > .

	crl [logicalNot] : < !(B1) ~> C, STORE > => < (not b1) ~> C, STORE1 > if
							< B1 ~> C, STORE > => < b1 ~> C , STORE1 > .

	crl [ifThen] : < (if B1 then C1 else C2) ~> C, STORE > => < C1 ~> C, STORE1 > if 
							< B1 ~> C, STORE > => < true ~> C, STORE1 > .
	crl [ifElse] : < (if B1 then C1 else C2) ~> C, STORE > => < C2 ~> C , STORE1 > if
							< B1 ~> C, STORE > => < false ~> C, STORE1 > .

	--- Conditie de oprire
	crl [whileDoStop] : < (while B1 do C1 od) ~> C , STORE > => < C, STORE1 > if
						< B1 ~> C, STORE > => < false ~> C, STORE1 > .

	--- Continua atat timp cat B1 este adevarata
	crl [whileDo] : < (while B1 do C1 od) ~> C, STORE > => < (while B1 do C1 od) ~> C, STORE2 > if 
						< B1 ~> C, STORE > => < true ~> C, STORE1 > /\
						< C1 ~> C, STORE1 > => < C, STORE2 > .

	crl [assignement] :  < (X <- E) ~> C, STORE > => < C, update(STORE1, X, I) > if 
							< E ~> C, STORE > => < I ~> C, STORE1 > .
 


endm 