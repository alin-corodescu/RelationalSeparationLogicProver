\documentclass[12pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage[english]{babel}
\usepackage{array}
\usepackage{tabularx}
\author{ANDREI-ALIN CORODESCU}
\title{Program Equivalence : Relational Separation Logic interactive prover implemented in Maude}
\begin{document}
\begin{titlepage}
\begin{center}
\textbf{
"ALEXANDRU IOAN CUZA" UNIVERSITY OF IAȘI
}
\\
\textbf{FACULTY OF COMPUTER SCIENCE}
\end{center}
   \vspace{40mm}
\begin{center}
	\Large\textbf {Program Equivalence : Relational Separation Logic interactive prover implemented in Maude}\\
	\vspace{40mm}
	\large\textit {ANDREI-ALIN CORODESCU}
	\\
	\vspace{20mm}
	\textbf{Session: }\textit{July, 2018}\\
	\vspace{30mm}
	\textbf{Scientific Coordinator}\\
	\textbf{\textit{Conf. Dr. Ciobâcă Ștefan}}
	\vspace{30mm}
\end{center}
\end{titlepage}
\tableofcontents
\pagebreak

\section{Introduction}
Comparing programs or code fragments and studying their equivalence is part of every software engineer's activities when they are testing an alternative implementation for an existing solution, fixing bugs, launching new product versions, etc . Naturally, for every process completed by persons there are efforts being made in order to make it more efficient, less error-prone and, in the end, automate the process all together. Once such as a task is automated in software engineering, it can be included in the flow of any research or development phase. An example benefiting from a formal proof of program equivalence is compiler optimization, where the optimized code needs to be equivalent to the input one . \\

The present paper describes the development of an interactive tool for arguing how to programs are related, based on studied and previously used theoretical concepts and technologies which facilitate the implementation of those concepts . \\

The tool represents an implementation of Hoare Logic - which allows formal reasoning about a program - , along  with 2 of its extensions, namely the Separation Logic (named Separation Logic from now on) and Relational Separation Logic \cite{relational} (named Relational Logic from now on). The 2 extensions simplify the Hoare Logic proofs, mainly using the "*" connector, allowing for local reasoning of effects of statements in a program . The tool has been implemented in Maude, a high performance logical framework with powerful metalanguage applications which facilitate the implementations of executable environments for logics.\\

The tool is built as a CLI which helps \cite{primer} \cite{SeparationLogic} \cite{JAVAITP} \cite{REWRITING} \cite{maudeprimer} \cite{manual} \cite{rewrConcurrency} \cite{cyclist} argue how two programs are related using Relational Separation Logic specifications. As a consequence of the dependency of Relational Separation Logic on Separation Logic, proofs about single programs using the latter are also supported by the tool. The tool has been developed with extensibility in mind, the main desired extensions being concurrent programs support and automatic proofs. \\

The rest of the paper is organized as follows: 
\begin{itemize}
	\item Section 1 will describe the language supported by the tool and a brief description of the logics utilized for reasoning .
	\item Section 2 will describe in detail the building process of the tool and how it can be used, with an accent on the features offered by the Maude language.
	\item Section 3 will present some of the research done on subjects related to the theme of the paper and discuss how those could be integrated into the current solution.
	\item Section 4 will present the conclusions of the paper, regarding both the theoretical and technical aspects of the paper.
\end{itemize}


\section{Contributions}
Personal contributions to the realization of the project : 
\begin{itemize}
	\item Modelled the Relational Logic and Separation Logic using Maude equational and rewriting logic specifications . 
	\item Executable semantics of a simple programming language using Maude
	\item Developed an interactive tool for reasoning about program behaviour using the aforementioned logics.
	\item Automation of some tasks which makes the tool more convenient to use .
	\item Examples of formal proofs done using the tool
\end{itemize}
\section{Theoretical Foundations}
In this section we will briefly present the theoretical aspects on which the project is based. 
\subsection{Language}
The prover supports expressing programs in a simple, imperative language, commonly used throughout papers \cite{SeparationLogic} \cite{primer} related to the subject of program verification, including the one describing Relational Separation Logic \cite{relational}, around  which this project is based. 
\subsubsection{Storage Model}
A state of in our storage model is defined by a pair consisting of a \(Store\) and a \(Heap\) .
\\
 Assuming that all the variables usable in programs from the set \(\mathtt{Vars}\) and the set of positive natural numbers is denoted by \(\mathtt{PosNats}\): \\
 
A \(Store\) is defined as:
\[ \mathtt{S} : \mathtt{Vars} \rightarrow \mathtt{PosNats} \]
 
A \(Heap\) represents a mapping from the \(\mathtt{PosNats}\) to \(\mathtt{Integers}\)
\[ \mathtt{H} : \mathtt{PosNats} \rightarrow \mathtt{Integers} \] 
More informally, the \(Store\) holds the value of the variables while the \(Heap\) maps the active memory cells during a program execution to their contents.
\subsubsection{Syntax and Semantics of the language}
\begin{figure}[h]
	\begin{tabularx}{\linewidth}{l  X}
	Integer Expressions& \(E ::= x \mid Integer \mid E\ \mathtt{plus}\ E \mid E\ \mathtt{times}\ E \mid E\ \mathtt{minus}\ E \) \\
	\\
	Boolean Expressions& \(B ::= false \mid true \mid B\ \mathtt{\&\&}\ B \mid  B\ ||\ B \mid B\  \mathtt{->}\ B \mid B \mathtt{<=>} B \mid \ ! B \mid E\ \mathtt{ge}\ E \mid E\ \mathtt{le}\ E \mid E\ \mathtt{eqs}\ E \)\\
	\\ 	
	Commands& \(C ::= x := alloc(E) \mid x := [E] \mid [E] := E \mid free(E) \mid x := E \mid C;C \mid if\ B\ then\ C\ else\ C \mid while\ B\ do\ C\ od \) \\
	\end{tabularx}
	\caption{Syntax of the language}
	\label{fig:langSyntax}
\end{figure}
The syntax of the language is presented in Figure \ref{fig:langSyntax} . It represents an adapted subset of the language presented in the Relational Separation Logic paper \cite{relational} . 
\paragraph{Semantics of the language}
The semantics of the previously defined language are standard but a few clarifications are necessary to point out how our language constructs interact with the storage model, as well as a few differences from regular programming languages:
\begin{itemize}
	\item{Verbosity of operators - most operators are replaced by their literal names ( \(+\) becomes \(\mathtt{plus}\) etc.); we have opted for this approach to avoid complication when implementing the language in Maude, because most of the operators are already defined in Maude for its built-in types, and overloading them could cause conflicts since we are basing our own defined types on Maude's primitives.}
		\subitem{\( B\ \mathtt{ge}\ B\) translates to the usual \(>=\) operator}
		\subitem{\( B\ \mathtt{le}\ B\) translates to the usual \(<=\) operator}
		\subitem{\( B\ \mathtt{eqs}\ B\) translates to the usual \(==\) equality comparison operator}
		\subitem{\( B\ \mathtt{->}\ B\) denotes implication between boolean expressions}
		\subitem{\(B\ \mathtt{<=>}\ B\) denotes equivalence between boolean expressions}
		\subitem{The rest of the operators are mostly similar to their C++ or Java counterparts and their semantics are self explanatory}
	\item{Memory allocation / deallocation: }
		\subitem{\(x := alloc(E)\) allocates a new cell in the memory, initializes it with the value of \(E\) and stores its address in the variable \(x\)}
		\subitem{\(x := free(E)\) deallocates the cell at the address equal to the value of \(E\)}
	\item{Working with variables and memory: }
		\subitem{\( x := [E] \) reads the contents of the memory cell at address \(E\) and stores the value in the variable \(x\)}
		\subitem{\( [E] := E\prime \) updates the contents of the memory cell at address \(E\) with the value of the expression \(E\prime\)}
		\subitem{\( x := E \) updates the value of the variable \(x\) with the value of the expression \(E\) - note that this command does not modify the heap in any way, as it usually happens with regular programming languages when updating the value of a variable}
\end{itemize}
\subsection{Hoare Logic}
Hoare Logic is a formal system which allows us to rigorously reason about the behaviour of programs.
The main component of Hoare Logic is the Hoare Triple, defined as follows:
\[ \{P\}\  C\  \{Q\} \]
where \(P\) denotes the state of the program before the execution of the command \(C\) and \(Q\) denotes the state of the program after the execution of \(C\). \\

The role of a Hoare triple is to capture how a command or set of commands modify the state of a program in a formal manner. \\

\(P\) and \(Q\), called precondition and postcondition, respectively can be specified using an assertion language . Figure \ref{fig:assertionSyntax} represents the assertion language, defined in relation with the language syntax: 
\vspace{1cm}
\begin{figure}
	\begin{tabularx}{\linewidth}{l  X}
		Assertions& \(P ::= B \mid P\ \Rightarrow\ P \mid P \land P \mid P \lor P \mid \neg P \mid {\exists x . P} \) \\
	\end{tabularx}
	\caption{Syntax of the assertion language}
	\label{fig:assertionSyntax}
\end{figure}
\\

At the base of proofs based on Hoare Logic are a set of axioms and proof rules which can be applied to Hoare triples. These axioms and rules will be discussed in the following section.
\subsection{Separation Logic}
Separation Logic is an extension of Hoare Logic which simplifies reasoning about program execution by introducing ways of localising parts of the proof : draw conclusions based on a subset of the program state, the subset chosen such that it contains only the parts relevant to the command specified by the analysed Hoare triple. \\

The main feature of Separation Logic is the \textbf{separating conjunction} \(*\) which allows to split the assertion into parts which refer to disjoint areas of the heap. Through the \(*\) operator, Separation Logic enables reasoning about the effects of commands only at a local level, by splitting the assertions into a section which is relevant to the current command and "saving" the rest for subsequent commands. \\

Separation Logic introduces new elements to the assertions language - Figure \ref{fig:SLassertionSyntax}:  \\

\begin{figure}
	\begin{tabularx}{\linewidth}{l  X}
		Assertions& \(P ::= ... (specified\ previously) \mid E \mapsto E \mid P * P \mid emp \) \\
	\end{tabularx}
	\caption{Syntax of the assertion language}
	\label{fig:SLassertionSyntax}
\end{figure}

\paragraph{Semantics of the new elements}
\begin{itemize}
	\item{\(E \mapsto E\prime \) means that the heap has an active cell at address \(E\), with the content \(E\prime\), and the cell is the \textbf{only} active cell in the heap}
	\item{\(P * Q\) holds for heap \(h\) iff \(\exists h_0,h_1\) such that \(h_0 * h_1 = h\) and \(P\) holds for \(h_0\) and \(Q\) holds for \(h_1\)}
	\item{\(emp\) denotes a heap without any active cells}
\end{itemize}
\subsection{Relational Separation Logic}
\subsection{Rewriting Logic}
\section{Relational Separation Logic Interactive Prover}
Ordinea subsectiunilor mai poate fi schimbata ulterior. Capitolul cel mai semnificativ din lucrare, va contine toate detaliile de implementare ale solutiei curente
\subsection{Maude - General Overview}
\subsection{Executable semantics of the language}
\subsection{Modelling the Separation Logics}
\subsection{Interaction by Maude LOOP-MAUDE}
\subsection{Prover execution flow}
\subsection{Automated processes}
\subsubsection{Automatic matching of axioms and previously proven goals}
\subsubsection{Automatic demonstration of implications}
\subsection{User Interface}
\subsection{Future directions}
\section{Additional Research}
\subsection{Automatic prover}
\subsection{Concurrent programs extension}
\subsection{Java+ITP}

\section{Conclusions}
\pagebreak
\bibliographystyle{unsrt}
\bibliography{bibliography}
\end{document}