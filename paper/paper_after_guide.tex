\documentclass[12pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage[english]{babel}
\usepackage{array}
\usepackage{tabularx}
\usepackage{tikz}
\usepackage{ebproof}
\usepackage[toc,page]{appendix}
\usepackage{listings}
\usepackage{graphicx}
\usepackage{url}
\usepackage{afterpage}

\newcommand\blankpage{%
	\null
	\thispagestyle{empty}%
	\addtocounter{page}{-1}%
	\newpage}
\author{ANDREI-ALIN CORODESCU}
\title{Program Equivalence : A Relational Separation Logic interactive prover implemented in Maude}
\newcommand{\hq}[4]{
	\left\{{#1}\right\}
	\let\scriptstyle\textstyle 
	\substack{{#2} \\ 	\let\scriptstyle\textstyle {#3}} 
	\left\{{#4}\right\}
}

\newcommand{\stoptocwriting}{%
	\addtocontents{toc}{\protect\setcounter{tocdepth}{-5}}}
\newcommand{\resumetocwriting}{%
	\addtocontents{toc}{\protect\setcounter{tocdepth}{\arabic{tocdepth}}}}
\usepackage{color}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}
\lstdefinestyle{mystyle}{
	backgroundcolor=\color{backcolour},   
	commentstyle=\color{codegreen},
	keywordstyle=\color{magenta},
	numberstyle=\tiny\color{codegray},
	stringstyle=\color{codepurple},
	basicstyle=\footnotesize,
	breakatwhitespace=false,         
	breaklines=true,                 
	captionpos=b,                    
	keepspaces=true,                 
	numbers=left,                    
	numbersep=5pt,                  
	showspaces=false,                
	showstringspaces=false,
	showtabs=false,                  
	tabsize=2
}

\lstset{style=mystyle}
\begin{document}
\begin{titlepage}
\begin{center}
\afterpage{\blankpage}
\textbf{
ALEXANDRU IOAN CUZA UNIVERSITY OF IAȘI
}
\\
\textbf{FACULTY OF COMPUTER SCIENCE}
\end{center}
   \vspace{40mm}
\begin{center}
	\Large\textbf {Program Equivalence: An Interactive Relational Separation Logic Prover Implemented in Maude}\\
	\vspace{40mm}
	\large\textit {ANDREI-ALIN CORODESCU}
	\\
	\vspace{20mm}
	\textbf{Session: }\textit{July, 2018}\\
	\vspace{30mm}
	\textbf{Scientific Coordinator}\\
	\textbf{\textit{Conf. Dr. Ciobâcă Ștefan}}
	\vspace{30mm}
\end{center}
\end{titlepage}

\tableofcontents
\pagebreak
\begin{abstract}
	Lucrarea de față descrie procesul de dezvoltare al unui utilitar interactiv utilizat în analiza formală a programelor, folosindu-se de Logica Separatoare Relațională \cite{relational} și Logica Separatoare \cite{primer} \cite{SeparationLogic}, utilizând Maude \cite{maudesite} drept cadru de dezvoltare. Componenta interactivă se îmbină cu o componentă automatizată, prin care părți din demonstrație vor fi realizate automat. Lucrarea este orientata pe rezolvarea problemei prin intermediul funcționalităților oferite de Maude și va include secvențe de cod ce vor ilustra conceptele cheie legate de modelarea si aplicarea fundamentelor teoretice utilizate pe parcursul proiectului.
\end{abstract}
\section*{Introduction}
In the present paper I describe the development of an interactive tool for reasoning about how two programs are related, in a formal manner. \\


The tool is an implementation of Hoare Logic, which allows formal reasoning about a program along with two of its extensions, namely the Separation Logic and Relational Separation Logic \cite{relational}. The two extensions simplify the Hoare Logic proofs, mainly using the "*" connector, allowing for local reasoning about the effects of statements in a program. I have the tool implemented in Maude, a high performance logical framework with powerful metalanguage applications that facilitate the implementation of executable environments for logics.\\

The tool is built as a CLI that helps with reasoning about how two programs are related using Relational Separation Logic specifications. As a consequence of the dependency of Relational Separation Logic on Separation Logic, proofs about single programs using the latter are also supported by the tool. The tool has been developed with extensibility in mind, the main desired extensions being concurrent programs support and automatic proofs. \\

The paper is organized as follows: 
\begin{itemize}
	\item {\textbf{Section 1} describes the main personal contributions to the realization of this project;}
	\item {\textbf{Section 2} presents the problem this project aims to solve;}
	\item {\textbf{Section 3} shortly presents some other projects related to this one;}
	\item {\textbf{Section 4} briefly touches upon the theoretical foundations of this project, together with the technologies used to implement them;}
	\item {\textbf{Section 5}, the main section of this paper, presents my approach to solving the problem, and discuss how it can be improved in the future.}
\end{itemize}
\section{Contributions}
Personal contributions:
\begin{itemize}
	\item Modelling the Relational Separation Logic and Separation Logic using Maude equational and rewriting logic specifications; 
	\item Developing an interactive tool for reasoning about program behaviour using the aforementioned logics;
	\item Automation of tasks that make the tool more convenient to use;
	\item Example of formal proof performed using the tool - Appendix \ref{proofExample}
\end{itemize}
Throughout the development of the prover, I have learned how to use a different, unfamiliar technology, that is a good fit for  modelling theoretical concepts which were also new to me. This learning by applying process properly introduced me to both the technology and the logics involved in formally verifying program equivalence. 
\section{Description of the Problem}
Comparing programs or code fragments and studying their equivalence is part of the activities of every software engineer, when they are testing an alternative implementation for an existing solution, fixing bugs, launching new product versions, etc. Naturally, for every process completed manually there are efforts being made in order to make it more efficient, less error-prone and, in the end, automate the process all together. These goals can be achieved by creating an easy to use and reliable formal  method of verifying program equivalence.
\\

An example benefiting from a formal proof of program equivalence is compiler optimization, where the optimized code needs to be equivalent to the input one \cite{relational}.\\

The problem this project aims to solve is reducing the gap between theoretical and practical aspects of formal proofs for program equivalence by creating an executable environment for Relational Separation Logic in which the user can prove the equivalence of programs. Through the creation of such a tool, the theoretical concepts become more accessible, easier to apply and understand. Making formal verification methods more accessible leads to an overall increase in the quality of software, by replacing the existing methods of verifying equivalence, that are often prone to errors, with more robust ones.\\

The difficult aspects of creating this tool include:
\begin{itemize}
	\item Losing as little generality as possible when modelling the theoretical concepts in a programming language;
	\item Approaching computationally-hard problems required for Relational Separation Logic proofs;
	\item Understanding the complexities of Relational Separation Logic and create a user experience which facilitate the application of the logic.
\end{itemize}

\section{Previous work}
Previous work related to the topic has been done mostly in terms of Separation Logic based tools, with Relational Separation Logic not being treated as much. \\

A notable example which also uses the same framework as this project, namely Maude, is the Java+ITP\cite{JAVAITP} tool, which enables analysis of Java programs using Separation Logic. The implementation relies heavily on Maude's ITP (inductive theorem prover).
\\

Several other tools are presented or referenced in \cite{primer}.

\section{Theoretical Foundations and technologies}
This section will briefly introduce the concepts on which the project is based, together with the technologies used to implement it, along with a few references to resources which explain them in depth.
\subsection{Separation Logic}
Separation Logic allows for reasoning about the effects of code on the program state in a formal manner. The main abstraction used in separation logic is the \textbf{Hoare Triple}:
\[ \{P\}\  C\  \{Q\} ,\]
where \(P\) denotes the a condition satisfied by state of the prover before the execution of the command \(C\) and \(Q\) denotes another condition satisfied by state of the prover after the execution of \(C\).
\\

Good references for reading on separation logic include: 
\begin{itemize}
	\item \cite{primer} - for a good introduction and some interesting usages ;
	\item \cite{SeparationLogic} - for a more in depth explanation, including the mathematical fundaments of the logic.
\end{itemize} 
\subsection{Relational Separation Logic}
Relational Separation Logic, which is the central concept of our project builds upon Separation Logic to reason about how two programs are related, by using the concept of a \textbf{Hoare Quadruple}:
\[\{R\}\ {C_1 \atop C_2}\   \{T\},\]
where \(R\) represents a \textbf{relation} between the two program states holding before the execution of commands \(C_1\) and \(C_2\), while \(T\) represents a \textbf{relation} that holds after the execution of the two commands. 
\\

Relational Separation Logic is presented in detail in \cite{relational}.
\subsection{Maude}
Maude \cite{maudesite} is a framework based on rewriting logic \cite{rewritingLogic} which allows for natural representations of a wide range of applications, including other logics, which made it a perfect fit for our case. Maude allows for short and simple, yet clever and self-explanatory solutions to problems. 
\\

 Good references for Maude language include:
 \begin{itemize}
 	\item The Maude Primer \cite{primer}, which was written for Maude 2.0.1 but still applies to the latest versions of Maude is a good starting point for learning Maude, as it introduces the language in a more informal, friendlier way;
 	\item The Maude Manual \cite{manual}, which presents the whole Maude system in depth, along with the mathematical foundations;
 	\item "All about Maude" book \cite{allAboutMaude}, which includes everything contained in the manual and presents some of the more relevant tools implemented in Maude.
 \end{itemize}
\section{Relational Separation Logic Interactive Prover} 
This section includes details related to the implementation and usage of the Relational Separation Logic prover and highlights a few of the features provided by Maude that made it a language fit for the purpose of this project.
\\

The information presented in this section assumes a degree familiarity with Maude, especially the META-LEVEL module, and with the underlying theoretical concepts implemented by the prover (Separation Logic and Relational Separation Logic). References for these can be found in the previous section.
\\

This section includes snippets of Maude code, but since Maude is a very expressive and self-explanatory language, I have not included a complete presentation of every language construct defined for the scope of this project. The ideas presented are accompanied by some examples and key features of the implementation. For a more detailed presentation, please refer to the code itself.
\subsection{Language}
The prover supports expressing programs in a simple, imperative language, commonly used throughout papers  \cite{primer} \cite{SeparationLogic} related to the subject of program verification, including the one describing Relational Separation Logic \cite{relational}, around  which this project is based. 
\subsubsection{Storage Model}
A state of in our storage model is defined by a pair consisting of a \texttt{Store} and a \texttt{Heap}.
\\
The set of program variables is \(\mathtt{Vars}\). The set of positive natural numbers is denoted by \(\mathtt{PosNats}\): 
\begin{flushleft}
A \texttt{Store} is defined as:
\[ \mathtt{S} : \mathtt{Vars} \rightarrow \mathtt{PosNats} .\]

A \texttt{Heap} represents a mapping from the \(\mathtt{PosNats}\) to \(\mathtt{Integers}\) and is defined as:
\[ \mathtt{H} : \mathtt{PosNats} \rightarrow \mathtt{Integers} .\] 
\end{flushleft}
Informally, the \texttt{Store} holds the value of the variables while the \texttt{Heap} maps the active memory cells during a program execution to their contents.
\subsubsection{Syntax and Semantics of the language}
\begin{figure}[h]
	\noindent\rule{\linewidth}{0.4pt}
	\begin{tabularx}{\linewidth}{l  X}
		Integer Expressions& \(E ::= x \mid \textit{Integer} \mid E\ \mathtt{plus}\ E \mid E\ \mathtt{times}\ E \mid E\ \mathtt{minus}\ E \) \\
		\\
		Boolean Expressions& \(B ::= \textit{false} \mid \textit{true} \mid B\ \mathtt{\&\&}\ B \mid  B\ ||\ B \mid B\  \texttt{->}\ B \mid B \texttt{<=>} B \mid \ ! B \mid E\ \mathtt{ge}\ E \mid E\ \mathtt{le}\ E \mid E\ \mathtt{eqs}\ E \)\\
		\\ 	
		Commands& \(C ::= x := alloc(E) \mid x := [E] \mid [E] := E \mid free(E) \mid x := E \mid C;C \mid if\ B\ then\ C\ else\ C \mid while\ B\ do\ C\ od \) \\
	\end{tabularx}
	\caption{Syntax of the language}
	\label{fig:langSyntax}
	\noindent\rule{\linewidth}{0.4pt}
\end{figure}
The syntax of the language is presented in Figure \ref{fig:langSyntax}. It represents a subset of the language presented in the Relational Separation Logic paper \cite{relational}. 
\paragraph{}
{
	The semantics of the previously are standard, but a few clarifications are necessary to point out how our language constructs interact with the storage model, as well as a few differences from regular programming languages:
	\begin{itemize}
		\item{Verbosity of operators - most operators are replaced by their literal names (\(+\) becomes \(\mathtt{plus}\) etc.). I have opted for this approach to avoid syntactic complication when implementing the language in Maude, because most of the operators are already defined in Maude for its built-in types, and overloading them could cause conflicts since we are basing our own defined types on Maude's primitives.}
		\subitem{\( B\ \mathtt{ge}\ B\) translates to the usual \(\geq\) operator}
		\subitem{\( B\ \mathtt{le}\ B\) translates to the usual \(\leq\) operator}
		\subitem{\( B\ \mathtt{eqs}\ B\) translates to the usual \(=\) equality comparison operator}
		\subitem{\( B\ \texttt{->}\ B\) denotes implication between boolean expressions}
		\subitem{\(B\ \texttt{<=>}\ B\) denotes equivalence between boolean expressions}
		\subitem{The rest of the operators are self-explanatory}
		\item{Memory allocation / deallocation: }
		\subitem{\(x := alloc(E)\) allocates a new memory cells, initializes it with the value of \(E\) and stores its address in the variable \(x\);}
		\subitem{\(free(E)\) deallocates the cell at the address equal to the value of \(E\).}
		\item{Working with variables and memory: }
		\subitem{\( x := [E] \) reads the contents of the memory cell at address \(E\) and stores the value in the variable \(x\);}
		\subitem{\( [E] := E\prime \) updates the contents of the memory cell at address \(E\) with the value of the expression \(E\prime\);}
		\subitem{\( x := E \) updates the value of the variable \(x\) with the value of the expression \(E\). Note that this command does not modify the heap in any way, as it usually happens with regular programming languages when updating the value of a variable.}
	\end{itemize}
	\paragraph{Maude Modelling of the Language}
	We define sorts corresponding to language elements and their associated operators:
	\begin{itemize}
		\item \texttt{AExp} for Integer expressions in the specification. To capture the first two possible forms of Integer expressions in Figure \ref{fig:langSyntax}, the AExp sort is a super sort of \texttt{Int} in the standard \texttt{INT} module and \texttt{Id}, which is the sort defined for variables;
		\item \texttt{BExp} for the Boolean Expressions type in the specification. It is a super sort of \texttt{Bool} of standard module \texttt{BOOL}; 
		\item \texttt{Command} for programs.
	\end{itemize}
	An example of a translation from specification to Maude code is presented in Listing \ref{code:languageGrammer}. Note that we have opted to skip the attributes associated with the operators, as they are irrelevant for the purpose of this example.
	\\
	
	\begin{lstlisting}[label=code:languageGrammer,caption=Example of operator translation to Maude code]
	op while_do_od : BExp Command -> Command [...].
	op _:=_ : Id AExp -> Command [...]. 
	\end{lstlisting}
	
	\paragraph{Executable semantics of the language, in Maude}
	Maude also supports specifying executable semantics for the language using rewriting logic \cite{rewrConcurrency}. A proof of concept for a language similar to the one used by the prover is present in the code of the project (\textbf{simpleLanguage.maude}), but it is out of scope for the presentation of the prover. An executable environment for the programming language used in the prover is a valid candidate for future improvements.

 
\subsection{Modelling the Separation Logics}
Thanks to the ability of Maude to naturally represent logics, the modelling of Separation Logic and Relational Separation Logic is mostly reduced to translating the logical formulae into appropriate syntax for Maude, making the representational distance (the amount of information lost when representing a theoretical concept into a programming language) \cite{manual} almost non existent. \\

Each proof rule in the Separation Logic and Relational Separation Logic has been translated into a Maude rewrite rule. The prover is centered around the concept of \textbf{Goals} which can be one of the three things: 
\begin{itemize}
	\item {Hoare Quadruple} - corresponding to Relational Separation Logic;
	\item {Hoare Triple} - corresponding to Separation Logic;
	\item {Implication between relations and assertions}.
\end{itemize} 
The proof rules are interpreted in a bottom-up manner, meaning that, applying a rule to a goal, which must match the conclusion of the used rule, will generate new goals consisting of the hypothesis: Listing \ref{slConseq} presents how a Separation Logic rule has been translated into Maude syntax and Listing \ref{rslConseq} presents the same process for the Relational Separation Logic counterpart of the rule.
\begin{flushleft}
	The Separation Logic rule of \textsf{Consequence}
\end{flushleft}
	\medskip
	\[
	\begin{prooftree}
	\Hypo{P \Rightarrow P\prime}
	\Hypo{\{P\prime\} C \{Q\prime\}}
	\Hypo{Q\prime \Rightarrow Q}
	\Infer 3 {\{P\}\  C  \{Q\}}
	\end{prooftree}	
	\]
	Is represented in Maude syntax as: 
\begin{lstlisting}[caption=Separation Logic Consequence rule,label=slConseq]
	rl [SeparationLogic-Consequence] : {P} C {Q} => ((P => P1) <> ({P1} C {Q1})) <> (Q1 => Q) [nonexec] .
\end{lstlisting}
\begin{flushleft}
	The Relational Separation Logic rule of \textsf{Consequence}
\end{flushleft}
	\[
	\begin{prooftree}
	\Hypo{R \Rightarrow R_1}
	\Hypo{\hq{R_1}{C}{C\prime}{S_1}}
	\Hypo{S_1 \Rightarrow S}
	\Infer 3 {\hq{R}{C}{C\prime}{S}}
	\end{prooftree}	
	\]
	is represented in Maude syntax as: 
	\begin{lstlisting}[caption=Relational Separation Logic Consequence rule,label=rslConseq]
	rl [Consequence] : { R } C1 -- C2  { S } => ((R => R1) <> ({R1} C1 -- C2 {S1})) <> (S1 => S) [nonexec] .
	\end{lstlisting}
The \texttt{<>} operator is used to separate sub-goals generated by the rule.
\\

The \texttt{---} operator is used to separate the two snippets of code mentioned in the \textbf{Hoare Quadruple}.
\\

All the rules are given the attribute \texttt{[nonexec]} because we want them to be applied in a controlled manner, at the meta-level. Some of the rules, including the examples, are not even valid executable Maude rules, because they make use of variables before binding them For example, in the Separation Logic rule of \textsf{Consequence}, \texttt{P1} is used in a rule before it is bound. At the meta-level, however we can manually bind values to those variables, as we will show when discussing how we apply these rules to goals.
\subsubsection{Sort Hierarchy}
Much in the same manner as we modelled the language grammar, Relational Separation Logic and Separation Logic have been modelled by defining sorts and declaring operators using these sorts. The main point of reference for our modelling has been \cite{relational}, for both logics. Some examples of translations from specification to code are included below.
\begin{itemize}
	\item \texttt{Assertion} is the sort used to handle Separation Logic assertions. It is a super sort of the \texttt{BExp} sort defined as part of our language;
	\item \texttt{HoareTriple} is the sort for Separation Logic \textbf{Hoare Triples} (Listing \ref{HT}):
	\begin{lstlisting}[caption=Hoare Triple constructor operator,label=HT]
op {_}_{_} : Assertion Command Assertion -> HoareTriple .\end{lstlisting}
	\item \texttt{Relation} is the sort for Relational Separation Logic relations. As with \texttt{Assertion}, it is a super sort of the \texttt{BExp} sort of our language. Because both the \texttt{Relation} and \texttt{Assertion} are super sorts of the same sort, Maude will display a few warnings which are not affecting functionality, but in the future, creating a separate \texttt{BExp} sort for both the \texttt{Assertion} and \texttt{Relation} sorts would be a better option.
	\item \texttt{HoareQuadruple} denotes the concept with the same name, in the context of Relational Separation Logic .\\
	Listing \ref{HQ} language constructs relevant for Relational Separation Logic.
	\begin{figure}[h]
	\begin{lstlisting}[caption=Examples of Relational Separation Logic specific constructs,label=HQ]
--- Operator which creates a relation from two assertions
op [_;_] : Assertion Assertion -> Relation .
--- Operator which constructs a Hoare Quadruple 
op {_}_--_{_} : Relation Command Command Relation -> HoareQuadruple .\end{lstlisting}
	\end{figure}
\end{itemize}
The other operators for the Assertion and Relation languages have been defined in the same manner as the programming language operators, following their presentation in \cite{relational}.

\subsection{Interaction by Maude LOOP-MODE}
Our Relational Separation Logic prover is implemented as an interactive CLI program, based on the LOOP-MODE module of Maude, which is the entry point for any interactive Maude application. The LOOP-MODE module provides the only way to store a state between commands. In this chapter we will discuss how we handle input and output, the structure of a state and the role every element plays in the execution of the prover.\\

We will make a distinction between \textbf{Loop state}, which is specific to Maude and the \textbf{Prover state}, which is specific to our use-case, and holds the necessary data related to the state of the proof we are currently working on. The \textbf{Prover state} is encapsulated within \textbf{Loop state} (see Figure \ref{fig:states}).
\begin{figure}[h]
	\includegraphics[width=\textwidth]{"pictures/States".png}
	\caption{Loop and Prover State structure}
	\label{fig:states}
\end{figure}
\subsection{State of the Prover}
Following the examples in the Maude Manual \cite{manual}, our prover state (Figure \ref{fig:states}) is composed of multiple sections modified accordingly during the execution of the prover:
\begin{itemize}
	\item{\texttt{Action} - represents the current action to be executed by the prover;}
	\item{\texttt{Root Goal} - represents the end-goal of the proof;}
	\item{\texttt{Current Goal} - the goal being treated currently - all actions will be applied to this goal;}
	\item{\texttt{Goal Stack} - stack of goals necessary to be proven in order to prove the root goal. The current goal is the last element popped from the stack and new elements are generated and pushed by the application of proof rules to the current goal;}
	\item{\texttt{Proven Goals} - list of goals that have already been proven, or axioms. Each goal will be first checked to see if it matches any goal in this list to prevent repeating the same proofs;}
	\item{\texttt{Staging Output} - contains the output generated by the current action, before being passed to the Loop state. This staging mechanism enables each rewriting rule to generate output independent of the others.}
\end{itemize}
\subsection{Input and Output Handling}
To understand how our prover handles input and output, it is important to note that the flow of the LOOP-MODE module is as follows: 
\begin{enumerate}
	\item User input is placed in the \(\mathtt{INPUT}\) member of the loop state;
	\item Maude engine applies all the possible rewritings, resulting in a new loop state. All the logic of the prover is implemented here, in the form of rewriting rules which modify the prover state;
	\item The member \(\mathtt{OUTPUT}\) of the new loop state is taken and displayed at the console.
\end{enumerate}
There are two main rules used for handling input and output: 
\begin{enumerate}
	\item{The \texttt{in} rule (Listing \ref{inRule}), which is responsible for parsing user input and modifying the action in the prover state accordingly;}
	\begin{lstlisting}[caption=The \texttt{in} rule,label=inRule]
crl [in] : 
--- [ INPUT, <PROVER_STATE>, OUTPUT]
[QIL, < noRule ; RG ; G ; GS ; GL ; nil > , QIL']
=> 
if T:ResultPair? :: ResultPair  
--- If parsing succeeded, place the parsed action in
--- the prover state
then [nil, < downTerm(getTerm(T:ResultPair?), noAction) ; RG ; G ; GS ; GL ; nil >, QIL']  
--- If the parsing failed, display an error
else [nil, < noRule ; RG ; G ; GS ; GL ; nil >, 'ERROR QIL]  
fi  
--- Try to parse the input as an term of sort Action
if QIL =/= nil /\ T:ResultPair? := metaParse(upModule('PROVER-GRAMMAR, false), QIL, 'Action) .
\end{lstlisting}
	\item{The \texttt{out} rule (Listing \ref{outRule}), which takes the staging output from the prover state and appends it to the currently existing output in the loop state.}
	\begin{lstlisting}[caption=The \texttt{out} rule,label=outRule]
crl [out] :
[QIL, < A ; RG ; G ; GS ; GL ;  QIL' >, QIL'']
=> [QIL, < A ; RG ; G ; GS ; GL ; nil >, QIL''  QIL']
if QIL' =/= nil .
\end{lstlisting}
\end{enumerate}

\subsection{Prover Execution Flow}
This section describes the flow of a Relational Separation Logic proof using our prover. The most important parts of the execution of the prover are controlled through the first member of a prover state, \texttt{Action}, which specifies the next step in the processing of the current goal. There are two types of actions, \texttt{System Actions}, colored in the figure in purple and \texttt{User Actions}, colored in light-yellow. The diagram showing how the prover works is presented in Figure \ref{fig:ProverDiagram}.
\\
\begin{enumerate}
	\item The user issues the command \texttt{loop init .} in the Maude console. This will initialize the loop state;
	\item Now the user will have to specify the goal it wants to prove, by issuing the command \begin{center}(\texttt{prove(G)}),\end{center} where G is the representation of the goal using the syntax defined for our logics. The command will populate the required fields of the prover state (\texttt{RootGoal}, \texttt{GoalStack}) with G.
	\\
	
	This command will also populate the \texttt{ProvenGoals} list with axioms.
	\\
	
	Please note that the command is enclosed within parentheses, this being a requirement of the  Maude LOOP-MODE \cite{manual}. All the prover specific commands need to be enclosed in parenthesis. The previous command, \texttt{loop init .} was not enclosed because it is a Maude specific command, not something we want to pass as input to our prover;
	\item The next phase involves applying the logic proof rules to the goals in the \texttt{GoalStack} to generate sub-goals and prove them. Once a goal is popped from the \texttt{GoalStack}, it can be replaced by sub-goals generated by proof rules, matched with an proven goal / axiom, be proven automatically or be admitted manually. This phase lasts until there are no more goals left in the \texttt{GoalStack}, meaning that the \texttt{RootGoal} has been proven.
\end{enumerate}
\begin{figure}[h!]
	\includegraphics[width=\textwidth]{"pictures/Prover Flow".png}
	\caption{Prover Execution Diagram}
	\label{fig:ProverDiagram}
\end{figure} 
\clearpage
\subsubsection{User Actions}
User actions are the main entry point for user interaction and they describe how the user intends to process the current goal.
\begin{itemize}
	\item {Rule application action - indicates the application of a specific rule to the current goal, the action can be parametrized or not, depending on the rule. These actions are named following the pattern:	
	\begin{center}
		[\texttt{SL}] + \texttt{apply} + \textit{RuleName},
	\end{center}
		with \texttt{SL} being added only when applying Separation Logic rules, to distinguish between the Relational Separation Logic rules with the same name.
	}
		\begin{lstlisting}[label=userAction,caption=Rule Application Action]
	crl [applyConsequence] : < applyConsequence R1 -- S1 ; RG ; G ; GS ; GL ; nil > =>
		if SubGoals? :: Result4Tuple then 
		if downTerm(getTerm(SubGoals?), emptyGL) :: GoalList then
		< noAction ; RG ; noGoal ; downTerm(getTerm(SubGoals?), emptyGL) <> GS ; GL ; 'applied '  'consequence '  'rule '\n > 
		else
		< noAction ; RG ; G ; GS ; GL ; 'did ' 'not ' 'apply ' 'consequence '  'rule '\n > 
		fi
		else 
		< noAction ; RG ; G ; GS ; GL ; 'error '  'consequence '  'rule '\n > 
		fi 
	if SubGoals? := metaXapply(upModule('PROVER-INTERFACE, false), upTerm(G), 'Consequence, 'R1:Relation <- upTerm(R1) ; 'S1:Relation <- upTerm(S1) , 0, unbounded, 0).\end{lstlisting}
		The example given in Listing \ref{userAction} illustrates all the core concepts involved in the application of proof rules to goals: 
		\begin{itemize}
			\item The rewrite rule is applied to a \textbf{Prover state} that has the Action field equal to \texttt{applyConsequence R1 --- S1}, where \texttt{R1} and \texttt{S1} are parameters to be passed to the proof rule;
			\item The Consequence rule is applied at a meta level, using the \texttt{metaXapply} operator [line 11] from the \texttt{META-LEVEL} module. To this operator we also pass the values of the parameters (in their meta representation) with which to bind variables appearing in the \texttt{Consequence} rule;
			\item The result is then checked for errors to see if there were some errors when applying the \texttt{metaXapply} operator (line 8) or if the term returned is not actually of the required type (line 3);
			\item If the result corresponds to what the prover was expecting, we modify the state by adding the newly generated goals to the \texttt{GoalStack}, by moving down the meta-hierarchy - parsing meta-representation of terms;
			\item The last thing to note is an example of how the rules generate output independent of other applications. In the last field of the \texttt{Prover State}, as \texttt{StagingOutput}, there will be a list of quoted identifiers which will eventually get moved to the loop state and then outputted to the user.
		\end{itemize}
		All other actions which control the application of proof rules are written in a similar manner;
	\item {\(\mathtt{ok}\) action - admits the current goal;}
	\item {\(\mathtt{showGoal}\) action - prints the current goal to the console - it does not modify the state of the prover.}
	\item {\texttt{auto x}} action - instructs the prover to attempt to automatically prove an implication, by searching for a solution up to a depth of \texttt{x} rewrites. This command will do nothing if the current goal is not an implication. More details about the automated implication proving are included in the following section
\end{itemize}
\subsubsection{System Actions}
System actions mimic the behaviour of a "chain of responsibility" design pattern from object-oriented programming. The system actions are all applied in order before asking for user input. After a system action completes execution, it will decide the next action to be placed in the prover state. System actions are the main component through which our prover can be enriched with other features in the future. At the moment, the system actions are:
\begin{itemize}
	\item {\texttt{check}} - marks the current goal to be checked against previously proven goals or axioms;
	\item {\texttt{implication}} - marks the current goal to be run through the implication prover - in case the goal is an implication, try to prove it automatically;
	\item {\texttt{stop}} - when there are no more sub-goals to be proven, the prover should stop and indicate the success of proving the root goal.
\end{itemize}
\subsection{Automated Parts of the Relational Separation Logic Prover}
This section describes the functional parts of the prover which have been automated to make it more user-friendly and even prove sub-goals of the main demonstration by itself.
\subsubsection{Variable substitution}
In both sections describing automated processes we will interpret the equality operator between variables and replace, textually, one variable with the other in \texttt{Assertions}, \texttt{Relations} and \texttt{Commands}. The definition of the operator for \texttt{Assertions} is presented in Listing \ref{replaceOp}. The operator is defined recursively, with the base case being treated using the \texttt{owise} equational attribute. A similar approach is used for all the definitions of this operator. 
\begin{lstlisting}[label=replaceOp,caption=Replace operator definition for assertions]
op replace : Assertion Id Id -> Assertion .
eq replace(P * Q, X, Y) = replace(P, X, Y) * replace(Q, X , Y) .
eq replace(P /\ Q, X, Y) = replace(P, X, Y) /\ replace(Q, X, Y) .
eq replace(P \/ Q, X, Y) = replace(P, X, Y) \/ replace(Q, X, Y) .
eq replace(emp, X, Y) = emp .
eq replace(E |-> E2, X, Y) = replace(E, X, Y) |-> replace(E2, X, Y) .
eq replace(P, X, Y) = P [owise] .
\end{lstlisting}
\subsubsection{Automatic Recognition of Axioms and Previously Proven Goals}
The prover is capable of automatically recognizing goals matching an axiom or a previously proven goals, for a better user experience.
It achieves this goal by using \texttt{metaXmatch} operator included in the standard \texttt{META-LEVEL} module, which determines if two terms match. 

In terms of previously proven goals, the process is straight-forward, as it will compare terms in a literal manner (since they do not contain any variable).
\\

Axioms are modelled as terms with variables in them, allowing them to be matched by any term for which all variables in the axiom can be bound.
	For example, the axiom 
	\[
		\{E \mapsto -\} [E] := F \{E \mapsto F\}.
	\]
	is represented as a term of sort \texttt{HoareTriple}, but with free variables (Listing \ref{axiomRepr}):
	\begin{lstlisting}[caption=Example Axiom,label=axiomRepr]
	{E:AExp |-> _ } [E:AExp] := F:AExp {E:AExp |-> F:AExp}\end{lstlisting}
	
	
	However, Maude does not allow for variables to appear for the first time on the right hand side of a rewrite rule which needs to be used without meta-level computations (problem present when modelling the Separation Logic as well). We had to find a workaround for this problem and the solution we came up with was to write the axiom in its meta-representation, and then use the \texttt{downTerm} operator to bring it down in the meta-hierarchy (Listing \ref{axiom}).
	
	\begin{lstlisting}[label=axiom,caption=Initialization of Prover state]
rl [proveGoal] : < prove(HQ) ; RG ; G ; GS ; GL ; nil > =>
< noAction ; HQ ; noGoal ; HQ <> emptyGL ; 
downTerm('`{_`}_`{_`}['_|->_['E:AExp,'_:AExp],'`[_`]:=_['E:AExp,'F:AExp],'_|->_['E:AExp,'F:AExp]] , emptyGL)
--- ... [other axioms omitted for clarity] 
; 'begin '\n > .\end{lstlisting}
Before attempting to match terms we also interpret the equality between variables using the \texttt{replace} operator (Listing \ref{replaceSymb}) introduced previously to reduce the \texttt{Goal} to a simpler form, which might match to an axiom (Listing \ref{rewriteBeforeMatch}).
	\begin{lstlisting}[caption=Equation reducing the goal before attempting to match it,label=rewriteBeforeMatch]
ceq anyMatches(G, G1 <> GL) = G1
---if G := G1 .
if metaXmatch(upModule('PROVER-INTERFACE, false), 
upTerm(G1),
--- Try to reduce G as much as possible before matching
getTerm(metaRewrite(upModule('SYMBOLIC-EXECUTION, false), upTerm(G), unbounded)),
nil, 0, unbounded, 0) :: MatchPair .
	\end{lstlisting} 
	\begin{lstlisting}[caption=Rule intepreting variable equality,label=replaceSymb]
rl {P * (emp /\ X eqs Y)} X1 := E {Q} =>  
if X1 =/= X then 
{replace(P, X, Y)} replace(X1 := E, X, Y) {replace(Q, X, Y)}
else 
{replace(P, X, Y)} X1 := replace(E, X, Y) {Q}
fi .\end{lstlisting}

\subsubsection{Automatic Proof of Implications}
\label{autoImpl}
Automatic proof of implications is one of the most challenging aspects of this paper and this section will present our incipient approach to this problem.

We have modelled implication proof rules as rewrite rules in Maude (example in Listing \ref{implicationProofRule}), in order to make use of its \texttt{metaSearchPath} operator, which will search for a series of rewrites which transform a term into another.
\\
We used this functionality to try and solve implications 
\[
	R \Rightarrow S
\]
by searching for a series of rewrites from \texttt{R => S} to \texttt{true}. 
\\ 
\begin{lstlisting}[label=implicationProofRule,caption=Example of implication rewrite rules]
rl R:Relation * ( S:Relation \/ T:Relation ) => (R:Relation * S:Relation) \/ (R:Relation * T:Relation) .
--- Example for the usage of the replace operator
rl R * (Emp /\ X eqs Y) => replace(R, X , Y) .
rl (R:Relation => R:Relation) => true .
\end{lstlisting}
Most proof rules are of the form \(R \Leftrightarrow S\) and thus can be naturally expressed in our prover using rewrite rules. However, when the proof rules involve just a one way implication, such as \(Emp \Rightarrow Same\), if we were to model it simply as the first rule in the Listing \ref{implicationProofRule}, an implication, \texttt{Same => Emp} for example, could be wrongly considered true, because Maude would rewrite the \texttt{Emp} to \texttt{Same} and \texttt{Same => Same} evaluates to \texttt{true}. To prevent this from happening, we have constrained one-way implications by providing the entire context in which they can be rewritten:
\begin{lstlisting}
rl ((R * Emp) => S) => ((R * Same) => S) .
\end{lstlisting}

We have opted for the approach to search from the term \texttt{R => S} to \texttt{true} (Listing \ref{eqImplicationProving}) instead of searching from \texttt{R} to \texttt{S} because there are implications in which it is beneficial to use information from both sides in order to prove it. A simple example would be \texttt{R => true} which should evaluate to \texttt{true} - the rewrite rule corresponding to this implication is used in the proof at Appendix \ref{proofExample} - but if we were to search from \texttt{R} to \texttt{true}, the search will probably fail.
  
\begin{lstlisting}[label=eqImplicationProving,caption=Equation using the metaSearchPath operator]
op tryImplicationProving : Goal Int -> Trace? .
eq tryImplicationProving(RR:Relation => TT:Relation, depth:Int) = metaSearchPath(upModule('IMPLICATION-PROVER, false), upTerm(RR:Relation => TT:Relation),upTerm(true), nil, '* , depth:Int, 0) . 
\end{lstlisting}
If the implication has been proven automatically, the proof is correct with respect to the rewrite rules specified in the \textbf{implication-prover.maude} file. The approach however has an exponential running time since it searches exhaustively throughout the state space for a solution. \\

The second parameter controls the depth up to which the search goes. The prover will try automatically to search a solution within a depth of 3 rewrites, but the user can manually specify searching for a solution using the \texttt{auto x} command, where \texttt{x} is the depth up to which Maude should try to search the solution (our experiments show that searches up to a depth around 12 should finish use a reasonable amount of resources and finish in under 10 minutes - this observation of course depends on the implication and the number of possible rewrites starting from it). The found path is presented to the user if the implication has been proven. 
\\

Almost all the implications in Appendix \ref{proofExample} can be automatically proven, the exceptions being the ones for which the running time of the prover is too high, since they require a depth higher than 15 - those are manually admitted using the \texttt{ok} command.
\\

In the future, one might consider using Maude internal strategies \cite{manual} to control the rewriting and searching in the implication proving process, to make it follow heuristics and thus be more effective.
\paragraph{Inductive predicates} - the prover currently supports defining inductive predicates only by modifying the underlying Maude code (Listing \ref{indPred}). We have defined a single predicate, used in the Relational Separation Logic paper \cite{relational} :
\begin{lstlisting}[caption=Predicate syntax definition,label=indPred]
op List : Id -> Relation . 
\end{lstlisting}
In terms of the semantics of the \texttt{List} predicate, we have added rules to the \textbf{implication-prover.maude} file, to be considered when rewriting implications (Listing \ref{indPredSem}).
\begin{lstlisting}[caption=Example of rule interpreting the List predicate during implication proving,label=indPredSem]
rl [ (X:Id |-> E:AExp) * ((X:Id plus 1) |-> Y:Id) ; (X:Id |-> E:AExp) * ((X:Id plus 1) |-> Y:Id) ] * List(Y:Id) => List(X) .
\end{lstlisting}
\paragraph{Cyclist}\cite{cyclist} \cite{cyclistSite} is an automatic entailment prover for Separation Logic which we plan to integrate with our prover for Separation Logic implications and eventually extend to Relational Separation Logic, since it provides a generic framework. Since Maude does not easily support external commands, the idea would be to modify Maude's C++ code and add a hook for the \texttt{[special]} operator attribute which would invoke that hook, which will call the external command for Cyclist.
\subsection{User Interface}
Since our project aims to enable proofs of Separation Logic / Relational Separation Logic formulae, using an interactive prover, the user interface plays a major role in the success of the project - the easier it is to use and understand, the more chances of success it has. This idea has been presented in \cite{primer}, when discussing key elements of tools related to program verification. \\

Maude provides a simple, yet powerful system for controlling the output formatting of the CLI through which we aim to make the proofs more readable and user-friendly. \\

The Maude features we used for this prover's user interface are:
\begin{itemize}
	\item The \texttt{format} attribute of operators, which allows the programmer to control the style of the output when a term that makes use of the respective operator is printed to the console. It allows specifying modifiers for each possible white space in an operator, modifiers that will remain active until reset or until overriden. More information on the \texttt{format} attribute can be found in the Maude Manual \cite{manual}. 
	
	A sample output of the prover is presented in Figure \ref{fig:CLIScreenShot}, showcasing the manipulation of white spaces (newlines, indentation and spaces), usage of colours to distinguish between different elements - Relations are coloured in green, while the analysed code has it's keyword highlighted using cyan. The separator between the two pieces of code is also coloured in red;
	\begin{figure}[h]
		\includegraphics[width=\linewidth]{pictures/CLI.png}
		\caption{Formatted output of the prover}
		\label{fig:CLIScreenShot}
	\end{figure}
	\item The \texttt{metaPrettyPrint} operator in the \texttt{META-LEVEL} module, which returns a term as a list of quoted identifiers to be printed, formatted respecting the \texttt{format} attributes defined for the operators used in the term. An example is presented in Listing \ref{takeFirst}, which presents the rule used to take the top element of the \textbf{GoalStack} for processing, and writes the formatted output of the goal to the \textbf{StagingOutput} field.
	\begin{figure}[h]
	\begin{lstlisting}[label=takeFirst,caption=Rewrite rule making use of metaPrettyPrint]
crl [takeFirstGoalFromList] : < noAction ; RG ; noGoal ; G <> GS ; GL ; nil > 
=> 
< check ; RG ; G ; GS ; GL ; 'current ' 'goal '  '  'is '\n metaPrettyPrint(upModule('PROVER-INTERFACE, false), upTerm(G)) '\n > 
if G =/= noGoal .
	\end{lstlisting}
	\end{figure}
\end{itemize}
All throughout the prover calls to \texttt{metaPrettyPrint} have been made in order to inform the user of what the prover is doing and how.
\\

For a more advanced user interface or to expose the  functionalities of the prover through a programming interface, a wrapper written in more feature-rich language through which to control the Maude environment is probably the best choice. The concept is exemplified by the Maude plug-in for Eclipse (see \cite{maudeEclipsePLugin}) which enables writing of Maude code inside the Eclipse IDE, and the plug-in communicates with the underlying Maude environment. The project also includes a generic plug-in which allows any Java program to communicate with Maude.
\section*{Conclusions and Future Work}
The development of the Relational Separation Logic prover helped us get a deeper understating of it, along with an introduction to other theoretical concepts used in program analysis and programming language semantics, such as Separation Logic and Rewriting Logic.
\\

While the two Separation Logics used throughout the paper are powerful tools for analyzing the behavior of program and are relatively easy to understand, it takes time to become familiar and use them at their full potential.
\\

The logics are better suited for studying small snippets of code and not entire programs, because the demonstrations can get cumbersome and end up spending a lot of time on focusing on irrelevant parts of the program instead of its key sections. 
\\

Maude has been interesting to work because it required an entirely different mindset than the mainstream programming languages. Once grasping the concepts around Maude which was built, it was easy to come up with simple, clever solutions to the encountered problems. \\
As it is described on it's website \cite{maudesite}, Maude is a powerful logical framework which allows modelling of other logics in it; it proved to be exactly that, enabling us to represent the logics in a natural manner, which made the implementation much less error-prone and allowed us to focus on the relevant part of this project, namely how to apply the logics instead of focusing on how to properly implement them.
\\

While being a powerful and interesting language to work with, being fairly specialized and not very widespread, guidance and help are limited to the primer \cite{maudeprimer} and the manual \cite{manual}. This obstacle resulted in significant time spent on searching for solutions to otherwise trivial problems, especially when starting using the language, because the source of the problem is usually unclear to a beginner. 
\\

Overall, this whole project has been an interesting introduction to both  theoretical concepts regarding program analysis and new, different technologies. 
\\

Future directions of developing this project include support for concurrent programs and reducing the amount of required user input by automation. Immediate improvements which can be implemented for the prover include:
\begin{itemize}
	\item The ability to trace back the progress of a proof, and retry from intermediary states. This can be achieved by replacing the \textbf{GoalStack} with a directed graph structure in which nodes are \textbf{Goals} and arcs represent dependencies between the \textbf{Goals}.
	\item Implement a symbolic execution system for relations and assertions in order to be able to handle more complex proofs. The foundations of such a system are present in the current implementation, which interprets the equality between variables. For example, arithmetic expressions are a valid candidate for this system: in the current implementation, the expression \texttt{x plus (1 plus 2) } is different from the \texttt{x plus 3}.
	\item Improvements to the automatic proof of implications, with two of the options discussed in the Subsection \ref{autoImpl}
\end{itemize}


\bibliographystyle{unsrt}
\bibliography{bibliography}

\begin{appendices}
	\section{Example of proof using the prover}
	\label{proofExample}
	This appendix contains all the necessary commands to be run in a Maude console in order to run an example demonstration using the prover.
\begin{lstlisting}
load prover-interface.maude
loop init .
(prove(
{ 
((
Same 
*
List(c) 
*
[ y |-> x0 ; yp |-> x0 ]
) 
*
(y eqs yp /\ Emp))
*
(c eqs cp /\ Emp)
}
pass ; 
while (! (c eqs null))
do 
x := [y] ; 
[c] := 0 minus x ;
c := [c plus 1]
od
--
xp := [yp] ;
while (! (cp eqs null))
do 
[cp] := 0 minus xp ;
cp := [cp plus 1] 
od
{
(Same
*
(y eqs yp /\ Emp))
* 
(c eqs cp /\ Emp)
}
)
)
(applySequencing ( Same * List(c) * [ y |-> x0 ; yp |-> x0 ] * (y eqs yp /\ Emp) * (c eqs cp /\ Emp) * (xp eqs x0 /\ Emp) ) )
(applyFrameRule (Same * List(c) * (y eqs yp /\ Emp) * (c eqs cp /\ Emp)) )
(
applyConsequence
( [ (y |-> x0) ; (yp |-> x0) ] )
--
( [ (y |-> x0) ; ((yp |-> x0) * (xp eqs x0 /\ emp)) ] )
)
(applyEmbeddingRule)
(
applyConsequence
( Same * List(c) * (y eqs yp /\ Emp) * (xp eqs x0 /\ Emp) * (c eqs cp /\ Emp) * [y |-> x0 ; yp |-> x0] )
--
( (Same * List(c) * (y eqs yp /\ Emp) * (xp eqs x0 /\ Emp) * (c eqs cp /\ Emp) * [y |-> x0 ; yp |-> x0]) /\ !(!(c eqs null)) )
)
(applyLoop)
(applyConsequence
([(c0 |-> -) * ((c0 plus 1) |-> c1) * (y |-> x0) * (c eqs c0 /\ emp) 
; (c0 |-> -) * ((c0 plus 1) |-> c1) * (xp eqs x0 /\ emp ) * (cp eqs c0 /\ emp) ] 
* List(c1) * Same * (y eqs yp /\ Emp) * [emp ; yp |-> x0])
--
([(c0 |-> (0 minus x0)) * ((c0 plus 1) |-> c1) * (y |-> x0) * (c eqs c1 /\ emp) 
; (c0 |-> (0 minus x0)) * ((c0 plus 1) |-> c1) * (xp eqs x0 /\ emp ) * (cp eqs c1 /\ emp) ]
* List(c1) * Same * (y eqs yp /\ Emp) * [emp ; yp |-> x0])
)
(ok) 
(applyFrameRule (List(c1) * Same * (y eqs yp /\ Emp) * [emp ; yp |-> x0]))
(applyEmbeddingRule)
(SLapplySequencing ((c0 |-> (0 minus x0)) * ((c0 plus 1) |-> c1) * (y |-> x0) * (emp /\ c eqs c0)))
(SLapplySequencing ((c0 |-> -) * ((c0 plus 1) |-> c1) * (y |-> x0) * (emp /\ c eqs c0) * (emp /\ x eqs x0)))
(SLapplyFrameRule ((c0 |-> -) * ((c0 plus 1) |-> c1) * (emp /\ c eqs c0)))
(SLapplyFrameRule ( (y |-> x0) * ((c0 plus 1)|-> c1) ) )
(SLapplyFrameRule ( (y |-> x0) *  (c0 |->(0 minus x0)) ) )
(SLapplySequencing ((c0 |-> (0 minus x0)) * ((c0 plus 1) |-> c1) * (xp eqs x0 /\ emp) * (emp /\ cp eqs c0)))
(SLapplyFrameRule ( (c0 plus 1)|-> c1 ))
(SLapplyFrameRule  ((emp /\ (xp eqs x0) ) * (c0 |->(0 minus x0))) )
(ok)
(auto 9)
\end{lstlisting}
\end{appendices}

\end{document}