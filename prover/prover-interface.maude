
load prover-grammar.maude

load language/language_grammar.maude

mod PROVER-INTERFACE is
	including LOOP-MODE .
	including PROVER-GRAMMAR .
	including HOARE-QUADRUPLE .
	including LANGUAGE-GRAMMAR .
	protecting META-LEVEL .  

	--- A state in the REPL is represented as follows :
	--- 	Action = rule to be applied
	---		Goal = Root goal which we are trying to prove
	---		Goal = Current goal which is being proven - 
	---			needs to be linked to a node in the graph below
	--- 	GoalGraph = A graph of goals needed to be proven
	---		GoalList = A list of goals which we know are true  
	---		QidList = the output of the last action
	op <_;_;_;_;_;_> : Action Goal Goal GoalGraph GoalList QidList -> State .

	op init : -> System [ctor].

	eq init = [nil, < noRule ; noGoal ; noGoal ; emptyGL ; emptyGL ; nil >, nil ] .

	var A : Action . 
	var QIL QIL' QIL'' : QidList .
	--- Root goal
	var RG : Goal . 
	var G : Goal .
	--- Temporarily is just a list, will be turned into a graph
	var GG : GoalList . 
	var GL : GoalList . 

	--- Rule handling the input to the program
	crl [in] : 
		[QIL, < noRule ; RG ; G ; GG ; GL ; nil > , QIL']
		=> 
			if T:ResultPair? :: ResultPair  
	          then [nil,  
	                < downTerm(getTerm(T:ResultPair?), noRule) ; RG ; G ; GG ; GL ; nil >,  
	                QIL']  
	          else [nil, < noRule ; RG ; G ; GG ; GL ; nil >, 'ERROR QIL]  
	          fi  
		if QIL =/= nil
		 /\ T:ResultPair? := metaParse(upModule('PROVER-GRAMMAR, false), QIL, 'Action) .


    crl [out] :
       [QIL, < A ; RG ; G ; GG ; GL ;  QIL' >, QIL'']
       => [QIL, < A ; RG ; G ; GG ; GL ; nil >, QIL''  QIL']
       if QIL' =/= nil .



    --- begin interface rules 
    var HQ : HoareQuadruple .
    rl [proveGoal] : < prove(HQ) ; RG ; G ; GG ; GL ; nil > 
		=>
		< noRule ; HQ ; HQ ; HQ ; HQ ; 'begin > .
	
	--- end interface rules


	vars R S T : Relation .
	vars R1 R2 S1 S2 : Relation .
	var P Q V W P1 Q1 : Assertion .
	var X Y : Command .
	var C1 C2 C1' C2' : Command .
	var B B' : BExp . 
	var C C' : Command .
	var Var : Id .
	var SubGoals? : [Result4Tuple] .
	var SubGoals : GoalList .

	--- general format for action rules:
	---		Goal => GoalList . 
	rl [EmbeddingRule] : {P ; V} X -- Y {Q ; W} => {P} X {Q} {V} Y {W} [nonexec] .

	rl [FrameRule] : { R * T } X -- Y { S * T } => {R} X -- Y {S} [nonexec] .

	rl [SeparationLogic-FrameRule] :  {P} C {Q} => {P * V} C {P * V} [nonexec] .

	--- This rule will trigger a warning regarding using the S variable before being bound, but in the META-LEVEL it should be ok if we bind it manually
	rl [Sequencing] : { R }  C1 ; C2 -- C1' ; C2' { T } => { R } C1 -- C1' {S} {S} C2 -- C2' {T} [nonexec] . 

	rl [SeparationLogic-Sequencing] :  {P} C1 ; C2 {Q} => {P} C1 {V} {V} C2 {Q} [nonexec] .

	--- Same case as above for R1 and S1
	rl [Consequence] : { R } X -- Y { S } => ((R => R1) ({R1} X -- Y {S1})) (S1 => S) [nonexec] .

	rl [SeparationLogic-Consequence] : {P} C {Q} => ((P => P1) ({P1} C {Q1})) (Q1 => Q) [nonexec] .

	rl [Conjunction] : { R1 /\ R2 } X -- Y { S1 /\ S2 } => {R1} X -- Y {S1} {R2} X -- Y {S2} [nonexec] .

	rl [AuxVarElimination] : {exists Var . R} C -- C' {exists Var . S} => {R} C -- C' {S} [nonexec] .

	--- We need to add the condition under which this is true
	rl [SeparationLogic-AuxVarElimination] : {exists Var . P } C { exists Var .  Q} => {P} C {Q} [nonexec] .

	rl [Loop] : {R} while B do C od -- while B' do C' od {R /\ ! B} => (R => (B <=> B')) {R /\ B} C -- C' {R} [nonexec] .

	--- Here P is the loop invariant
	rl [SeparationLogic-Loop] : {P} while B do C od { ! B /\ P } => {P /\ B} C {P} [nonexec] .


	rl [ConditionalStatement] : {R} if B then C1 else C2 -- if B' then C1' else C2' {S} 
		=>
		((R => (B <=> B')) ({R /\ B} C1 -- C1' {S})) ({R /\ ! B} C2 -- C2' {S}) [nonexec] .

	rl [SeparationLogic-ConditionalStatement] : {P} if B then C1 else C2 {Q} => {B /\ P} C1 {Q} { ! B /\ P } C2 {Q} [nonexec] .


	crl [applyEmbeddingRule] : < applyEmbeddingRule ; RG ; G ; GG ; GL ; nil > 
		=>
		< noRule ; RG ; G ; GG downTerm(getTerm(SubGoals?), emptyGL) ; GL ; 'applied  > 
		if SubGoals? := metaXapply(upModule('PROVER-INTERFACE, false),
						upTerm(G), 'EmbeddingRule, none, 0, unbounded, 0) .

	crl [applyFrameRule] : < applyFrameRule T ; RG ; G ; GG ; GL ; nil >
		=>
		< noRule ; RG ; G ; GG downTerm(getTerm(SubGoals?), emptyGL) ; GL ; 'applied  > 
		if SubGoals? := metaXapply(upModule('PROVER-INTERFACE, false),
						upTerm(G), 'FrameRule, 'T:Relation <- upTerm(T), 0, unbounded, 0) .

	crl [SLapplyFrameRule] : < SLapplyFrameRule V ; RG ; G ; GG ; GL ; nil >
		=>
		< noRule ; RG ; G ; GG downTerm(getTerm(SubGoals?), emptyGL) ; GL ; 'applied  > 
		if SubGoals? := metaXapply(upModule('PROVER-INTERFACE, false),
						upTerm(G), 'SeparationLogic-FrameRule, 'V:Assertion <- upTerm(V), 0, unbounded, 0) .

	crl [applySequencing] : < applySequencing S ; RG ; G ; GG ; GL ; nil > 
		=>
		< noRule ; RG ; G ; GG downTerm(getTerm(SubGoals?), emptyGL) ; GL ; 'applied  > 
		if SubGoals? := metaXapply(upModule('PROVER-INTERFACE, false),
						upTerm(G), 'Sequencing, 'S:Relation <- upTerm(S), 0, unbounded, 0) .

	crl [SLapplySequencing] : < SLapplySequencing V ; RG ; G ; GG ; GL ; nil > 
		=>
		< noRule ; RG ; G ; GG downTerm(getTerm(SubGoals?), emptyGL) ; GL ; 'applied  > 
		if SubGoals? := metaXapply(upModule('PROVER-INTERFACE, false),
						upTerm(G), 'SeparationLogic-Sequencing, 'V:Assertion <- upTerm(V), 0, unbounded, 0) .

	crl [applyConsequence] : < applyConsequence R1 S1 ; RG ; G ; GG ; GL ; nil >
		=>
		< noRule ; RG ; G ; GG downTerm(getTerm(SubGoals?), emptyGL) ; GL ; 'applied  > 
		if SubGoals? := metaXapply(upModule('PROVER-INTERFACE, false),
						upTerm(G), 'Consequence, 'R1:Relation <- upTerm(R1) ; 'S1:Relation <- upTerm(S1) , 0, unbounded, 0) .


	crl [SLapplyConsequence] : < SLapplyConsequence P1 Q1 ; RG ; G ; GG ; GL ; nil >
		=>
		< noRule ; RG ; G ; GG downTerm(getTerm(SubGoals?), emptyGL) ; GL ; 'applied  > 
		if SubGoals? := metaXapply(upModule('PROVER-INTERFACE, false),
						upTerm(G), 'SeparationLogic-Consequence, 'P1:Assertion <- upTerm(P1) ; 'Q1:Assertion <- upTerm(Q1) , 0, unbounded, 0) .

	crl [applyConjunction] : < applyConjunction R1 R2 S1 S2 ; RG ; G ; GG ; GL ; nil >
		=>
		< noRule ; RG ; G ; GG downTerm(getTerm(SubGoals?), emptyGL) ; GL ; 'applied  > 
		if SubGoals? := metaXapply(upModule('PROVER-INTERFACE, false),
						upTerm(G), 'Conjunction, 'R1:Relation <- upTerm(R1) ; 'R2:Relation <- upTerm(R2) ; 'S1:Relation <- upTerm(S1) ; 'S2:Relation <- upTerm(S2) , 0, unbounded, 0) .

	--- todo the logical variable sort is  probably of sort qid or something, need to think this well
	crl [applyAuxVarElimination] : < applyAuxVarElimination Var ; RG ; G ; GG ; GL ; nil > 
		=>
		< noRule ; RG ; G ; GG downTerm(getTerm(SubGoals?), emptyGL) ; GL ; 'applied  > 
		if SubGoals? := metaXapply(upModule('PROVER-INTERFACE, false),
						upTerm(G), 'AuxVarElimination, 'Var:Id <- upTerm(Var), 0, unbounded, 0) .

	crl [SLapplyAuxVarElimination] : < SLapplyAuxVarElimination Var ; RG ; G ; GG ; GL ; nil > 
		=>
		< noRule ; RG ; G ; GG downTerm(getTerm(SubGoals?), emptyGL) ; GL ; 'applied  > 
		if SubGoals? := metaXapply(upModule('PROVER-INTERFACE, false),
						upTerm(G), 'SeparationLogic-AuxVarElimination, 'Var:Id <- upTerm(Var), 0, unbounded, 0) .

	crl [applyLoop] : < applyLoop ; RG ; G ; GG ; GL ; nil > 
		=>
		< noRule ; RG ; G ; GG downTerm(getTerm(SubGoals?), emptyGL) ; GL ; 'applied  > 
		if SubGoals? := metaXapply(upModule('PROVER-INTERFACE, false),
						upTerm(G), 'Loop, none, 0, unbounded, 0) .

	crl [SLapplyLoop] : < SLapplyLoop ; RG ; G ; GG ; GL ; nil > 
		=>
		< noRule ; RG ; G ; GG downTerm(getTerm(SubGoals?), emptyGL) ; GL ; 'applied  > 
		if SubGoals? := metaXapply(upModule('PROVER-INTERFACE, false),
						upTerm(G), 'SeparationLogic-Loop, none, 0, unbounded, 0) .

	crl [applyConditionalStatement] : < applyConditionalStatement ; RG ; G ; GG ; GL ; nil > 
		=>
		< noRule ; RG ; G ; GG downTerm(getTerm(SubGoals?), emptyGL) ; GL ; 'applied  > 
		if SubGoals? := metaXapply(upModule('PROVER-INTERFACE, false),
						upTerm(G), 'ConditionalStatement, none, 0, unbounded, 0) .

	crl [SLapplyConditionalStatement] : < SLapplyConditionalStatement ; RG ; G ; GG ; GL ; nil > 
		=>
		< noRule ; RG ; G ; GG downTerm(getTerm(SubGoals?), emptyGL) ; GL ; 'applied  > 
		if SubGoals? := metaXapply(upModule('PROVER-INTERFACE, false),
						upTerm(G), 'SeparationLogic-ConditionalStatement, none, 0, unbounded, 0) .



endm

--- red getTerm(metaXapply(upModule('PROVER-INTERFACE, false), upTerm( { 1 |-> 2 ; 1 |-> 2 } C D { 1 |-> 2 ; 1 |-> 2 } ), 'applyR, none, 0 , unbounded, 0 )) .
--- Maude> red getType(metaXapply(upModule('PROVER-INTERFACE, false), upTerm( { 1 |-> 2 ; 1 |-> 2 } C D { 1 |-> 2 ; 1 |-> 2 } ), 'applyR, none, 0 , unbounded, 0 )) .
---reduce in PROVER-INTERFACE : getType(metaXapply(upModule('PROVER-INTERFACE, false), upTerm({1 |-> 2 ; 1
   --- |-> 2}C D{1 |-> 2 ; 1 |-> 2}), 'applyR, none, 0, unbounded, 0)) .
--- rewrites: 5 in 0ms cpu (0ms real) (~ rewrites/second)
--- result Sort: 'GoalList
--- red downTerm(getTerm(metaXapply(upModule('PROVER-INTERFACE, false), upTerm( { 1 |-> 2 ; 1 |-> 2 } C D { 1 |-> 2 ; 1 |-> 2 } ), 'applyR, none, 0 , unbounded, 0 )), emptyGL) .